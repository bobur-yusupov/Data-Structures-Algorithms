\documentclass[a4paper,11pt]{article}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{hyperref}

% Page layout
\geometry{margin=1in}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textsc{Optimization of Prime Number Checking Algorithm}}
\fancyhead[R]{\thepage}
\fancyfoot[L]{\textsc{Bobur Yusupov}}
\fancyfoot[R]{\today}

% Title settings
\title{\LARGE \textbf{Optimization of Prime Number Checking Algorithm}}
\author{\large \textbf{Bobur Yusupov}\\ \small Bachelor student in Computer Science at  Eötvös Loránd University}
\date{\today}

% Code styling
\lstset{
    language=Python,
    frame=single,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green}\itshape,
    stringstyle=\color{red},
    showstringspaces=false,
    numbers=left,
    numbersep=5pt,
    numberstyle=\tiny\color{gray},
    keepspaces=true,
    breaklines=true,
    captionpos=b,
    morekeywords={def, return, if, while, print, for, range}
}

\begin{document}
\maketitle

\begin{abstract}
Prime number detection is a fundamental problem in number theory and computer science. This paper explores optimizations for naive primality test, reducing its computational complexity. We implement and analyze an improved algorithm using Python, leveraging mathematical properties to enhance efficiency.
\end{abstract}

\section{Introduction}
Optimization of algorithms is a critical component of computational efficiency. This paper discusses a basic prime number checking algorithm and explores various techniques for improving its performance. The initial algorithm, generated by ChatGPT, is as follows:

\begin{lstlisting}[caption={Naive Prime Number Checking Algorithm}, label={code:prime-check}]
def is_prime(n):
    if n <= 1:
        return False
    
    for i in range(2, n):
        if n % i == 0:
            return False
    
    return True
\end{lstlisting}

\section{Algorithm Description}
The given algorithm determines whether a number \textit{n} is prime through the following steps:
\begin{itemize}
    \item If \textit{n} is less than or equal to 1, return \texttt{False}.
    \item Iterate from 2 to \textit{n-1}, checking divisibility using the modulo operator.
    \item If \textit{n} is divisible by any \textit{i}, return \texttt{False} immediately; otherwise, return \texttt{True}.
\end{itemize}
This approach has a worst-case time complexity of \(O(n)\).

\section{Optimization Overview}
The primary inefficiency in the naive approach lies in its \(O(n)\) complexity. We explored several optimization techniques and implemented the most effective ones:
\begin{itemize}
    \item \textbf{Checking divisibility by 2 and 3}: First we check whether the number is even or not. If it is an even number we can immediately return \textbf{False}. This reduces the number of iterations, as every even number (except 2) can we skipped.
    \item \textbf{Reducing the range:} The concept of \textbf{Trial Division Method} is checking divisibility of \textit{n} from 2 to \(\sqrt{n} + 1\). If no divisor is found, we can conclude that \textit{n} is prime.
    \item \textbf{Skipping even numbers:} Except for 2, all prime numbers are odd. We can skip even numbers beyond 2.
\end{itemize}

\section{Optimized Algorithm}
Applying these optimizations, we derive the following improved algorithm:

\begin{lstlisting}[caption={Optimized Prime Number Checking Algorithm}, label={code:optimized-prime-check}]
import math

def is_prime_optimized(n):
    if n <= 1:
        return False
        
    if n <= 3:
        return True
        
    if n % 2 == 0 or n % 3 == 0:
        return False
        
    limit = int(math.sqrt(n)) + 1
    
    for i in range(5, limit, 2):
        if n % i == 0:
            return False
    
    return True
    
\end{lstlisting}

This optimization reduces the number of iterations significantly and improves the efficiency of prime number detection. The time complexity of the optimized algorithm is \( O(\sqrt{n}/2) \)

\section{Conclusion}
Optimizing algorithms is crucial in computer science. It leads to decrease usage of resources like memory, storage and time. Our algorithm might be simple and might not take too much time for smaller numbers, however for large numbers it requires use to wait.

Algorithm optimization is crucial in computer science, as it reduces resource usage, including memory, storage, and computation time. While naive approach might be sufficient for small numbers, however larger inputs require more resource usage. We can use more efficient methods to tackle with this issue. The optimized algorithm significantly reduces resource usage and execution time, making it more suitable for large-scale computations.
\end{document}
